/**
 * @file main.cpp
 *
 * @author Dan Keenan
 * @date 12/1/24
 * @copyright GNU GPLv3
 */

#include <array>
#include <boost/algorithm/string/classification.hpp>
#include <boost/algorithm/string/split.hpp>
#include <boost/algorithm/string/trim.hpp>
#include <fstream>
#include <iostream>
#include <map>
#include <ranges>
#include <regex>
#include <tinyxml2.h>

using Point = std::array<int, 2>;

struct FnSite {
  int id;
  Point position;
  char miningGrade;
  char revenueGrade;
  char combatGrade;
  int sightseeingSpots;
  std::vector<std::string> ore;
};

std::ostream &operator<<(std::ostream &os, const Point &point) {
  return os << "{" << point[0] << ", " << point[1] << "}";
}

std::ostream &operator<<(std::ostream &os,
                         const std::vector<std::string> &stringList) {
  using T = std::decay_t<decltype(stringList)>;
  os << "{";
  for (T::size_type i = 0; i < stringList.size(); ++i) {
    os << '"' << stringList[i] << '"';
    if (i != stringList.size() - 1) {
      os << ", ";
    }
  }
  return os << "}";
}

tinyxml2::XMLElement *findChildWithAttribute(tinyxml2::XMLElement *parent,
                                             const std::string &name,
                                             const std::string &attribute,
                                             const std::string &value) {
  auto element = parent->FirstChildElement(name.c_str());
  while (element != nullptr && element->Attribute(attribute.c_str()) != value) {
    element = element->NextSiblingElement(name.c_str());
    if (element == nullptr) {
      // No more siblings to check.
      break;
    }
  }
  return element;
}

int main(int argc, const char *argv[]) {
  if (argc != 4) {
    std::cerr << "Usage: sitelist <sites.csv> <map.svg> <out.cpp>" << std::endl;
    return 1;
  }

  std::map<unsigned int, FnSite> sites;

  // Load FN Site metadata.
  std::ifstream sitesCsvFile(argv[1]);
  if (!sitesCsvFile.is_open()) {
    std::cerr << "Failed to open sites csv " << argv[1] << std::endl;
    return 1;
  }
  std::string line;
  while (std::getline(sitesCsvFile, line)) {
    boost::algorithm::trim(line);
    if (line.empty() || line.at(0) == '#') {
      // Comment.
      continue;
    }
    std::vector<std::string> tokens;
    boost::algorithm::split(tokens, line, boost::algorithm::is_any_of(","));
    const auto siteId = std::stoi(tokens.at(0));
    sites.emplace(siteId, FnSite{
                              .id = siteId,
                              .position = {0, 0},
                              .miningGrade = tokens.at(1).at(0),
                              .revenueGrade = tokens.at(2).at(0),
                              .combatGrade = tokens.at(3).at(0),
                              .sightseeingSpots = std::stoi(tokens.at(4)),
                              .ore = {tokens.begin() + 5, tokens.end()},
                          });
  }
  sitesCsvFile.close();

  // Load node map positions.
  tinyxml2::XMLDocument svg;
  if (svg.LoadFile(argv[2])) {
    std::cerr << "Failed to open map svg " << argv[2] << std::endl
              << svg.ErrorStr() << std::endl;
    return 1;
  }
  // Find nodes group.
  auto nodesLayer =
      findChildWithAttribute(svg.RootElement(), "g", "id", "nodeslayer");
  if (nodesLayer == nullptr) {
    std::cerr << "Failed to find nodeslayer" << std::endl;
    return 1;
  }
  const std::regex reFnSiteId("FN(\\d+)");
  auto image = nodesLayer->FirstChildElement("image");
  if (image == nullptr) {
    std::cerr << "Failed to find image" << std::endl;
    return 1;
  }
  do {
    const std::string label = image->Attribute("inkscape:label");
    std::smatch match;
    if (!std::regex_match(label, match, reFnSiteId)) {
      continue;
    }
    const auto siteId = std::stoi(match[1].str());
    const auto x = image->IntAttribute("x");
    const auto y = image->IntAttribute("y");
    const auto width = image->IntAttribute("width");
    const auto height = image->IntAttribute("height");
    // Origin is top-left.
    sites[siteId].position = {x + width / 2, y + height / 2};
  } while ((image = image->NextSiblingElement("image")));

  // Write CPP definition file.
  std::ofstream out(argv[3], std::ios::trunc);
  if (!out.is_open()) {
    std::cerr << "Failed to open output file " << argv[3] << std::endl;
    return 1;
  }
  // Write header.
  out << "/* THIS FILE IS AUTOMATICALLY GENERATED */\n"
         "\n"
         "#include <QHash>\n"
         "#include \"FnSite.h\"\n"
         "\n"
         "const QHash<unsigned int, FnSite> FnSite::kAllSites{\n";
  for (const auto &site : std::views::values(sites)) {
    out << "  {" << site.id << ", {\n"
        << "    .id=" << site.id << ",\n"
        << "    .position=" << site.position << ",\n"
        << "    .miningGrade=FnSite::Grade::" << site.miningGrade << ",\n"
        << "    .revenueGrade=FnSite::Grade::" << site.revenueGrade << ",\n"
        << "    .combatGrade=FnSite::Grade::" << site.combatGrade << ",\n"
        << "    .sightseeingSpots=" << site.sightseeingSpots << ",\n"
        << "    .ore=" << site.ore << ",\n"
        << "  }},\n";
  }
  out << "};\n";

  return 0;
}
